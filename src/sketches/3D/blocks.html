<title></title>

<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix.js" data-head></script>
<script type="importmap" data-head>
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
  }
}
</script>
<script src="./lib/classes/ui.js"></script>
<script src="./lib/classes/tilegrid.js"></script>

<style>
  #controls {
    width: 100%;
  }

  #app {
    display:flex;
    width: 100%;
  }

  aside {
    width: 100%;
    max-width: 500px;
  }

  summary {
    position: relative;
  }

  .swatch {
    width: 24px;
    height: 24px;
    position: relative;
  }

  .swatch:after {
    content: "";
    display: block;
    position: absolute;
    inset: 0;
    opacity: 1;
    background-color: attr(value type(<color>), red);
  }

  details:has(.swatch[aria-label="red"]:checked) summary .swatch:after {
    background-color: red;
  }
  details:has(.swatch[aria-label="yellow"]:checked) summary .swatch:after {
    background-color: yellow;
  }
  details:has(.swatch[aria-label="green"]:checked) summary .swatch:after {
    background-color: green;
  }
  details:has(.swatch[aria-label="blue"]:checked) summary .swatch:after {
    background-color: blue;
  }

  input[type="radio"] {
    appearance: none;
  }

  summary, ul {
    list-style: none;
  }
  button {
    background-color: transparent;
    border: none;
    padding: 0;
  }

  details {
    position: relative;
  }

  details ul {
    padding: 0;
    display: flex;
    gap: 1rem;
    margin: 0;
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 0.2rem;
  }
  input[type="color"] { display: block }
  .colors {
    display: flex;
    text-align: center;
    justify-content: center;
    gap: 0.5rem;
  }
</style>

<div id="controls">
  <div id="app">
    <aside>
      <fieldset class="colors">
	<label for="color">Block
	  <input type="color" id="color" value="#ff0000" />
	</label>
	<label for="base-color">Base
	  <input type="color" id="base-color" value="#0000ff" />
	</label>
	<label for="bg-color">BG
	  <input type="color" id="bg-color" value="#cccccc" />
	</label>
      </fieldset>
      <fieldset>
	<div>
	  <label for="blockWidth">Block width</label>
	  <input id="blockWidth" type="range" min="1" max="5" value="2" />
	</div>
	<div>
	  <label for="blockDepth">Block depth</label>
	  <input id="blockDepth" type="range" min="1" max="5" value="2" />
	</div>
      </fieldset>
    </aside>
  </div>
</div>

<script>
  const ui = new UI().initialize({
    blockWidthInput: document.getElementById('blockWidth'),
    blockDepthInput: document.getElementById('blockDepth'),
    colorInput: document.getElementById('color'),
    baseColorInput: document.getElementById('base-color'),
    bgColorInput: document.getElementById('bg-color')
  });

  ui.registerAction('blockWidthChange', ui.elements.blockWidthInput, 'input');
  ui.registerAction('blockDepthChange', ui.elements.blockDepthInput, 'input');
  ui.registerAction('colorChange', ui.elements.colorInput, 'input');
  ui.registerAction('baseColorChange', ui.elements.baseColorInput, 'input');
  ui.registerAction('bgColorChange', ui.elements.bgColorInput, 'input');
</script>

<script type="module" id="sketch">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let colors = [
  new THREE.Color().setRGB(1,0,0),
  new THREE.Color().setRGB(0,1,0),
  new THREE.Color().setRGB(0,0,1),
  new THREE.Color().setRGB(1,1,0),
];

class Tile {
  constructor(row, col, pos, w, d) {
    this.row = row;
    this.col = col;
    this.x = pos.x;
    this.y = pos.y;
    this.z = pos.z;
    this.w = w;
    this.h = 0.5;
    this.d = d;
    this.maxHeight = 0;
    this.blocks = [];
    this.bounds = new THREE.Box3();
    this.calculateBounds();
    this.overlaps = [];
    this.cellBounds = new THREE.Box3();
    this.cellBounds.copy(this.bounds);
    this.boundsHelper = new THREE.Box3Helper(this.cellBounds);
    //this.drawBounds();
  }

  calculateBounds() {
    this.bounds = new THREE.Box3(
      new THREE.Vector3(this.x-this.w/2, 0, this.z-this.d/2),
      new THREE.Vector3(this.x+this.w/2, this.h+this.maxHeight, this.z+this.d/2)
    );
    if (this.boundsHelper) {
      //this.drawBounds();
    }
  }

  drawBounds() {
    scene.remove(this.boundsHelper);
    this.boundsHelper.dispose();
    this.boundsHelper = new THREE.Box3Helper(this.cellBounds);
    scene.add(this.boundsHelper);
  }

  calculateOverlaps(tiles, blockWidth, blockDepth) {
    this.overlaps = [];
    this.maxHeight = 0;
    this.cellBounds.copy(this.bounds);
    let eX = (blockWidth - this.w)/8;
    let eZ = (blockDepth - this.d)/8;
    this.cellBounds.expandByVector(new THREE.Vector3(eX, 100, eZ));
    if (blockWidth % 2 == 0) this.cellBounds.translate(new THREE.Vector3(this.w/2, 0, 0));
    if (blockDepth % 2 != 0) this.cellBounds.translate(new THREE.Vector3(0, 0, -this.d/2));

    let maxHeight = 0;
    for (let tile of tiles) {
      for (let block of tile.blocks) {
        if (this.cellBounds.intersectsBox(block.bounds)) {
	  maxHeight = Math.max(maxHeight, block.y);
        }
      }
    }
    this.maxHeight = maxHeight;
  }

  addChild(child, callback) {
    this.children.push(child);
  }

  removeChild(i) {
    this.children.splice(i, 1);
  }

  addBlock(x, y, z, w, h, d, c) {
    let block;
    block = new Block(x, y, z, w*this.w, h, d*this.d, c, new THREE.MeshPhysicalMaterial({ reflectivity: 0.8 }));

    this.blocks.push(block);
    block.show();
  }

  removeBlock(i) {
    if (this.maxHeight > 0) {
      scene.remove(this.blocks[i].group);
      this.blocks.splice(i, 1);
      this.maxHeight-=this.h;
    }
  }
}

class Block {
  constructor(x, y, z, w, h, d, c, m) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    this.h = h;
    this.d = d;
    this.c = c.clone();
    this.dotSize = 0.1;
    this.dots = [];
    this.meshes = [];
    this.group = new THREE.Group();
    this.material = m;
    m.color = this.c.clone();
    let box = this.createBox();
    box.geometry.computeBoundingBox();
    this.group.position.set(this.x, this.y + this.h/2, this.z);
    this.bounds = box.geometry.boundingBox.translate(this.group.position);
    const boundsHelper = new THREE.Box3Helper(this.bounds);
    boundsHelper.material.color = 0x0000ff;
    //if (this.y > 0) scene.add(boundsHelper);
    this.createDots();
  }

  setColor(c) {
    this.c = c;
    this.material.color = c;
  }

  createBox() {
    const geometry = new THREE.BoxGeometry(this.w, this.h, this.d);
    let mesh = new THREE.Mesh( geometry, this.material.clone() );
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    this.meshes.push(mesh);
    this.group.add(mesh);
    return mesh;
  }

  createDots() {
    this.getDotPositions();
    this.dots.forEach(dot => {
      const c1Geometry = new THREE.CylinderGeometry( 0.2, 0.2, 0.2); 
      const c1Mesh = new THREE.Mesh( c1Geometry, this.material );
      c1Mesh.position.x = dot.x;
      c1Mesh.position.y = dot.y;
      c1Mesh.position.z = dot.z;
      this.meshes.push(c1Mesh);
      this.group.add(c1Mesh);
    })
  }

  show() {
    scene.add( this.group );
  }

  getDotPositions() {
    let marginX = 0.15;
    let marginZ = 0.15;
    const dotsX = this.w * 2;
    const dotsZ = this.d * 2; 
    const totalWidthForDots = this.w - (2 * marginX) - (this.dotSize * 2);
    const totalDepthForDots = this.d - (2 * marginZ) - (this.dotSize * 2);
    const spacingX = totalWidthForDots / (dotsX - 1);
    const spacingZ = totalDepthForDots / (dotsZ - 1);

    for (let z = 0; z < dotsZ; z++) { 
      for (let x = 0; x < dotsX; x++) { 
	this.dots.push({
	  x: -this.w/2 + marginX + this.dotSize + (spacingX * x),
	  y: this.h/2,
	  z: -this.d/2 + marginZ + this.dotSize + (spacingZ * z)
	});
      }
    }
  }
}

let camera, scene, renderer, orbitControls, raycaster, pointer, grid, mouseLight, blockWidth, blockDepth;
let cursor;
let menuWidth = 300;
init();

function init() {
  blockWidth = 2;
  blockDepth = 2;

  camera = new THREE.PerspectiveCamera( 70, (window.innerWidth-menuWidth) / window.innerHeight, 0.1, 100 );
  camera.position.y = 10;
  camera.position.z = 5;
  camera.lookAt(new THREE.Vector3(0, 0, 0));

  let width=20;
  let height = 10;
  raycaster = new THREE.Raycaster();
  pointer = new THREE.Vector2();

  scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xCCCCCC );

  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth-menuWidth, window.innerHeight );
  renderer.setAnimationLoop( animate );
  renderer.domElement.setAttribute("id", "scene");
  document.querySelector("#app").appendChild( renderer.domElement );
  ui.registerCanvas('canvas#scene');

  orbitControls = new OrbitControls( camera, renderer.domElement );

  const light = new THREE.AmbientLight( 0xf3f3f3 );
  scene.add( light );

  const directionalLight = new THREE.DirectionalLight( 0xffffff, 9 );
  directionalLight.position.x = 5;
  scene.add( directionalLight );

  mouseLight = new THREE.PointLight( 0xffffff, 9, 4 );
  scene.add(mouseLight);

  window.addEventListener( 'resize', onWindowResize );

  grid = new TileGrid(20, 20, 0.5, 0.5, ({ row, col, pos, rowSize, colSize }) => {
    return new Tile(row, col, pos, rowSize, colSize);
  });
  for (let y = 0; y < grid.cols; y+=2) {
    for (let x = 0; x < grid.rows; x+=2) {
      let i = x+y*grid.rows;
      let tile = grid.tiles[i];
      tile.addBlock(
	tile.x+tile.w/2,
	tile.y,
	tile.z,
	2,
	tile.h,
	2,
	colors[2],
	new THREE.MeshPhysicalMaterial({ reflectivity: 0.7 })
      );
      tile.blocks[0].show();
    }
  }
  let firstBlock = grid.tiles[0].blocks[0];
  cursor = new Block(
    firstBlock.x,
    firstBlock.y+grid.tiles[0].h,
    firstBlock.z,
    blockWidth/2,
    firstBlock.h,
    blockDepth/2,
    new THREE.Color( 0xffffff ),
    new THREE.MeshBasicMaterial( { wireframe: true } )
  );
  cursor.show();

  ui.onCanvasMouseMove( onPointerMove );
  ui.onCanvasClick( onClick );
  ui.on("blockWidthChange", (e) => {
    blockWidth = e.target.value;
    scene.remove(cursor.group);
    cursor = new Block(
      cursor.group.position.x,
      cursor.group.position.y,
      cursor.group.position.z,
      blockWidth/2,
      cursor.h,
      blockDepth/2,
      new THREE.Color( 0xffffff ),
      new THREE.MeshBasicMaterial( { wireframe: true } )
    );
    scene.add(cursor.group);
    grid.tiles.forEach(t => {
      t.calculateBounds();
      t.calculateOverlaps(grid.tiles, blockWidth, blockDepth);
    });
  });
  ui.on("blockDepthChange", (e) => {
    blockDepth = e.target.value;
    scene.remove(cursor.group);
    cursor = new Block(
      cursor.group.position.x,
      cursor.group.position.y,
      cursor.group.position.z,
      blockWidth/2,
      cursor.h,
      blockDepth/2,
      new THREE.Color( 0xffffff ),
      new THREE.MeshBasicMaterial( { wireframe: true } )
    );

    grid.tiles.forEach(t => {
      t.calculateBounds();
      t.calculateOverlaps(grid.tiles, blockWidth, blockDepth);
    });
    scene.add(cursor.group);
  });

  ui.on('baseColorChange', (e) => {
    grid.tiles.forEach(tile => tile.blocks[0]?.setColor(new THREE.Color().setStyle(e.target.value)))
  });
  ui.on('bgColorChange', (e) => {
    scene.background = new THREE.Color().setStyle(e.target.value);
  });
  window.addEventListener( 'contextmenu', onRightClick );
}

function animate() {
  if (renderer?.domElement) orbitControls.update();
  raycaster.setFromCamera( pointer, camera );

  //reset state
  grid.tiles.forEach(tile => {
    tile.blocks.forEach(block => {
      block.meshes.forEach(mesh => mesh.material.color = block.c.clone());
    });
  });
  grid.resetActiveTile();

  //get intersections
  let active = grid.tiles.find(tile => {
    return raycaster.ray.intersectsBox(tile.bounds);
  });

  //do stuff with intersected tile
  if (active) {
    mouseLight.position.set(active.x, active.y+3, active.z) ;
    grid.setActiveTile(active.row, active.col);
    let pos = new THREE.Vector3(active.x, active.maxHeight + active.h, active.z);
    if (blockWidth % 2 == 0) pos.x += active.w/2;
    if (blockDepth % 2 != 0) pos.z -= active.d/2;
    cursor.group.position.set(pos.x, pos.y + cursor.h/2, pos.z);
  }

  renderer.render( scene, camera );

}

function onClick( event ) {
  let tile = grid.getActiveTile();
  if (!tile) return;
  let x = tile.x;
  let z = tile.z;
  if (blockWidth % 2 == 0) x += tile.w/2;
  if (blockDepth % 2 != 0) z -= tile.d/2;
  tile.addBlock(
    x,
    tile.maxHeight+tile.h,
    z,
    blockWidth,
    tile.h,
    blockDepth,
    new THREE.Color().setStyle(ui.elements.colorInput?.value),
    new THREE.MeshBasicMaterial()
  );
  tile.calculateBounds();
  grid.tiles.forEach(t => {
    t.calculateOverlaps(grid.tiles, blockWidth, blockDepth);
  });
}

function onWindowResize() {
  camera.aspect = (window.innerWidth-menuWidth) / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth-menuWidth, window.innerHeight );
}

function onRightClick( event ) {
  event.preventDefault();
  let tile = grid.getActiveTile();
  tile.removeBlock(tile.blocks.length-1);
  tile.calculateBounds();
  grid.tiles.forEach(t => {
    t.calculateOverlaps(grid.tiles, blockWidth, blockDepth);
  })
  return false;
}

function onPointerMove( event ) {

  // calculate pointer position in normalized device coordinates
  // (-1 to +1) for both components

  pointer.x = ( (event.clientX-menuWidth) / (window.innerWidth - menuWidth) ) * 2 - 1;
  pointer.y = - ( event.clientY / (window.innerHeight) ) * 2 + 1;

}

</script>

