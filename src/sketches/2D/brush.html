<script src="./lib/p5.min.js" data-head></script>
<script src="./lib/components/range.js" data-head></script>

<style>
  canvas {
    border: 4px solid;
  }
</style>

<div id="controls">
  <input type="color" id="stroke" />
  <input id="opacity" is="my-range" value="0.5" />
  <input id="strokeWidth" is="my-range" value="0.5"/>
  <input id="bleed" is="my-range" value="0.9"/>
  <button type="button" id="clear">Clear</button>
</div>
<script id="sketch">
let g, brush, ui;
function setup() {
  createCanvas(500, 500);
  strokeCap(PROJECT);
  g = createGraphics(width, height);
  ui = new UI(); 
  brush = new Brush(ui.getWidth(), ui.getColor(), ui.getOpacity());
}

function draw() {
  const bleed = 255-(ui.getBleed() * 255);
  background(255, 255, 255, bleed);
  if (mouseIsPressed) {
    brush.setBaseWeight(ui.getWidth());
    brush.setColor(ui.getColor());
    brush.setOpacity(ui.getOpacity());
    brush.draw(g);
  }
  filter(BLUR);
  image(g, 0, 0);
}    

function mouseReleased() {
  prevWeight = 0;
}

class Brush {
  constructor(w, c, o) {
    this.baseWeight = parseFloat(w);
    this.weight = parseFloat(w); 
    this.prevWeight = parseFloat(w);
    this.color = color(c);
    this.opacity = parseFloat(o);
  }

  setBaseWeight(scale) {
    this.baseWeight = scale * 20;
  }

  setColor(value) {
    this.color = color(value);
  }

  setOpacity(value) {
    this.opacity = map(value, 0, 1, 2, 30);
  }

  draw(g) {
    let speed = dist(pmouseX, pmouseY, mouseX, mouseY);
    let segments = max(ceil(speed * 2), 1); 
    
    let targetWeight = map(speed, 0, 50, this.baseWeight, this.baseWeight+50);
    
    let smoothedWeight = lerp(this.prevWeight, targetWeight, 0.1);

    for (let i = 0; i < segments; i++) {
      let t1 = i / segments;
      let t2 = (i + 1) / segments;
      
      let x1 = lerp(pmouseX, mouseX, t1);
      let y1 = lerp(pmouseY, mouseY, t1);
      let x2 = lerp(pmouseX, mouseX, t2);
      let y2 = lerp(pmouseY, mouseY, t2);
      
      let segmentWeight = lerp(this.prevWeight, smoothedWeight, (t1 + t2) / 2);
      
      g.stroke(red(this.color), green(this.color), blue(this.color), this.opacity);
      g.strokeWeight(segmentWeight);
      g.line(x1, y1, x2, y2);
    }
    
    // Store the smoothed weight for next frame
    this.prevWeight = smoothedWeight;
  }
}

class UI {
  constructor() {
    this.colorInput = document.getElementById('stroke');
    this.opacityInput = document.getElementById('opacity');
    this.widthInput = document.getElementById('strokeWidth');
    this.bleedInput = document.getElementById('bleed');
    this.clearButton = document.getElementById("clear");
    this.clearButton.addEventListener("click", () => {
      colorInput.value = "#000000";
      g.clear()
      clear();
    });
  }

  getBleed() {
    return parseFloat(this.bleedInput.value);
  }

  getWidth() {
    return parseFloat(this.widthInput.value);
  }

  getColor() {
    return this.colorInput.value;
  }

  getOpacity() {
    return parseFloat(this.opacityInput.value);
  }
}
</script>
