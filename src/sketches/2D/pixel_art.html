<style>
#controls {
   width: 450px;
}

input#cursor {
  width: 100%;
  max-width: none;
}
</style>

<script src="./lib/p5.min.js" data-head ></script>
<script src="./lib/components/range.js" data-head ></script>

<div id="controls">
  <input id="cursor" type="range" min=0 max=0 />
  <fieldset>
    <button type="button" id="copy-frame">Copy frame</button>
    <button type="button" id="paste-frame">Paste frame</button>
    <button type="button" id="play">Play</button>
    <button type="button" id="pause">Pause</button>
    <button type="button" id="stop">Stop</button>
  </fieldset>
  <fieldset>
    <input type="color" id="color"/>
    <input type="radio" id="pencil" value="pencil" name="mode"/>
    <label for="pencil">Pencil</label>
    <input type="radio" id="line" value="line" name="mode"/>
    <label for="line">Line</label>
    <input type="radio" id="eraser" value="eraser" name="mode"/>
    <label for="eraser">Eraser</label>
  </fieldset>
  <fieldset>
    <div>
      <label for="frameRate">Frame rate</label>
      <input type="number" id="frameRate" value="12"/>
    </div>
    <div>
      <label for="frames">Number of Frames</label>
      <input type="number" id="frames" value="12"/>
    </div>
  </fieldset>
</div>

<script id="sketch">
let rows, cols, rowWidth, colWidth, timeline, UI, currentColor, mode;
function setup() {
  createCanvas(450, 450);
  rows = 32;
  cols = 32;
  rowWidth = width/rows;
  colWidth = height/cols;
  timeline = new AnimationManager();
  filledCells = [];
  rectMode("CENTER");
  currentColor = color(0);

  mode = 'pencil';

  UI = initializeUI();
  UI.on('playheadMove', (e) => timeline.scrub(parseInt(e.target.value)));
  UI.on('copyFrame', () => timeline.copyAnimationFrame());
  UI.on('pasteFrame', () => timeline.pasteAnimationFrame());
  UI.on('play', () => timeline.play());
  UI.on('pause', () => timeline.pause());
  UI.on('stop', () => timeline.stop());
  UI.on('frameRateChange', (e) => timeline.frameRate = parseInt(e.target.value));
  UI.on('frameCountChange', (e) => timeline.setNumFrames(parseInt(e.target.value)));
  UI.on('colorChange', (e) => currentColor = color(e.target.value));
  UI.on('mousePress', () => handleDraw(true));
  UI.on('mouseDrag', () => handleDraw());
  UI.on('modeChange', (e) => mode = e.target.value);

  timeline.frameRate = parseInt(UI.frameRateInput.value);
  timeline.setNumFrames(parseInt(UI.frameCountInput.value));
}

function draw() {
  background(255);
  timeline.update();

  UI.playhead.value = timeline.currentFrame;
  UI.playhead.max = timeline.animation.length - 1;
  if (timeline.playState == 'playing') {
  } else {
    let prevCells = timeline.getPrevFrame().filledCells;
    drawGrid();
    for (const cell of prevCells) {
      let x = (rowWidth*cell.row);
      let y = (colWidth*cell.col);
      fill(255, 0, 0, 20);
      noStroke();
      rect(x, y, rowWidth, colWidth);
    }
  }


  let cells = timeline.getFrame().filledCells;
  for (const cell of cells) {
    let x = (rowWidth*cell.row);
    let y = (colWidth*cell.col);
    fill(cell.color);
    noStroke();
    rect(x, y, rowWidth, colWidth);
  }
}

function drawGrid() {
  push();
  stroke(0, 0, 0, 20);
  for (x = 0; x < rows; x++) {
    line(x*rowWidth, 0, x*rowWidth, height); 
  }

  for (y = 0; y < cols; y++) {
    line(0, y*colWidth, width, y*colWidth);
  }
  pop();
}

function handleDraw(isClick = false) {
  switch(mode) {
    case 'pencil':
      timeline.getFrame().drawPoint(mouseX, mouseY);
      break;
    case 'line':
      if (isClick) timeline.getFrame().startLine(mouseX, mouseY);
      else timeline.getFrame().updateLine(mouseX, mouseY);
      break;
    case 'eraser':
      timeline.getFrame().erasePoint(mouseX, mouseY);
  }
}

function initializeUI() {
  let elements = {
    canvas: document.querySelector('.p5Canvas'),
    playhead: document.getElementById("cursor"),
    copyFrameButton: document.getElementById("copy-frame"),
    pasteFrameButton: document.getElementById("paste-frame"),
    playButton: document.getElementById('play'),
    pauseButton: document.getElementById('pause'),
    stopButton: document.getElementById('stop'),
    frameRateInput: document.getElementById('frameRate'),
    frameCountInput: document.getElementById('frames'),
    colorInput: document.getElementById('color'),
    modeInputs: document.querySelectorAll('[name="mode"]'),
  }

  let mouseDown = false;

  elements.canvas.addEventListener('mouseup', () => mouseDown = false);
  elements.canvas.addEventListener('mouseleave', () => mouseDown = false);

  const on = (eventName, callback) => {
    switch(eventName) {
      case 'mousePress':
	elements.canvas.addEventListener('mousedown', (e) => {
	  mouseDown = true;
	  callback(e);
	});
	break;	
      case 'mouseDrag':
	elements.canvas.addEventListener('mousemove', (e) => {
	  console.log(mouseDown);
	  if (!mouseDown) return;
	  console.log('dragged');
	  callback(e);
	});
	break;	
      case 'playheadMove':
	elements.playhead.addEventListener('input', callback);
	break;
      case 'copyFrame':
	elements.copyFrameButton.addEventListener('click', callback);
	break;
      case 'pasteFrame':
	elements.pasteFrameButton.addEventListener('click', callback);
	break;
      case 'play':
	elements.playButton.addEventListener('click', callback);
	break;
      case 'pause':
	elements.pauseButton.addEventListener('click', callback);
	break;
      case 'stop':
	elements.stopButton.addEventListener('click', callback);
	break;
      case 'colorChanged':
	elements.colorInput.addEventListener('change', callback);
      case 'frameRateChange':
	elements.frameRateInput.addEventListener('change', callback);
	break;
      case 'frameCountChange':
	elements.frameCountInput.addEventListener('change', callback);
	break;
      case 'modeChange':
	elements.modeInputs.forEach(radio => radio.addEventListener('click', callback));
    }
  }
  return { ...elements, on };
}


class AnimationManager {
  constructor() {
    this.currentFrame = 0;
    this.progress = 0;
    this.frameRate = 1;
    this.frameAccumulator = 0;
    this.playState = 'idle';
    this.animation = [];
    this.clipboard = null;
    this.lastRequestedFrame = 0;
  }

  play() {
    this.playState = 'playing';
  }

  pause() {
    this.playState = 'paused';
  }

  stop() {
    this.playState = 'idle';
    this.currentFrame = 0;
    this.frameAccumulator = 0;
  }

  copyAnimationFrame() {
    this.clipboard = this.animation[this.currentFrame];
  }
  
  pasteAnimationFrame() {
    this.animation[this.currentFrame] = this.clipboard.copy();
  }

  setNumFrames(n) {
    if (n > this.animation.length) {
      const numItemsToAdd = n - this.animation.length;
      for (let i = 0; i < numItemsToAdd; i++) {
	this.animation.push(new Frame());
      }
    } else {
      const numItemsToDelete = this.animation.length - n;
      this.animation.splice(this.animation.length - 1 - numItemsToDelete, numItemsToDelete);
    }
  }

  getFrame() {
    let frame = this.animation[this.currentFrame];
    this.lastRequestedFrame = this.currentFrame;
    return frame;
  }

  getPrevFrame() {
    if (this.currentFrame === 0) return this.animation[0];
    let frame = this.animation[this.currentFrame-1];
    return frame;
  }

  needsUpdate() {
    return this.currentFrame != this.lastRequestedFrame;
  }

  scrub(cursor) {
    this.currentFrame = cursor;
  }

  update() {
    if (this.playState == 'playing') {
      this.frameAccumulator += deltaTime / 1000;
      
      const frameTime = 1 / this.frameRate;
      while (this.frameAccumulator >= frameTime) {
	this.currentFrame = (this.currentFrame+1)%this.animation.length;
	this.frameAccumulator -= frameTime;
      }
      this.progress = this.currentFrame / Math.min(this.animation.length);
    }
  }
}

class Frame {
  constructor(cells = []) {
    this.filledCells = cells;
    this.line = new BresenhamLine();
    this.prevLineLength = 0;
  }

  startLine(x, y) {
    const cellCoords = new Cell(x, y);
    this.line.start(cellCoords.row, cellCoords.col);
    this.prevLineLength = 0;
  }

  updateLine(newX, newY) {
    const cellCoords = new Cell(newX, newY);
    this.line.calculate(cellCoords.row, cellCoords.col);
    for (let i = 0; i < this.prevLineLength; i++) {
      this.filledCells.pop();
    }
    this.prevLineLength = 0;
    for (const cell of this.line.points) {
      const existingCell = this.filledCells.find(filledCell => filledCell.id === cell.id);
      if (existingCell) {
	existingCell.color = cell.color;	
      } else {
	this.filledCells.push(cell);
	this.prevLineLength++;
      }
    }
  }

  drawPoint(x, y) {
    const cell = new Cell(x, y, currentColor);
    const existingCell = this.filledCells.find(filledCell => filledCell.id === cell.id);
    if (!existingCell) this.filledCells.push(cell);
  }

  erasePoint(x, y) {
    const cellCoords = new Cell(x, y);
    const existingCellIdx = this.filledCells.findIndex(filledCell => filledCell.id === cellCoords.id);
    if (existingCellIdx > -1) {
      this.filledCells.splice(existingCellIdx, 1);
    }
  }

  copy() {
    return new Frame([...this.filledCells]);
  }
}

class BresenhamLine {
  constructor() {
    this.startX = 0;
    this.startY = 0;
    this.points = [];
  }

  start(startX, startY) {
    this.points = [];
    this.startX = startX;
    this.startY = startY;
  }
  
  calculate(newX, newY) {
    this.points = [];
    const dx = Math.abs(newX - this.startX);
    const dy = Math.abs(newY - this.startY);
    const sx = this.startX < newX ? 1 : -1;  // step direction
    const sy = this.startY < newY ? 1 : -1;
    let err = dx - dy;  // error accumulator
    
    let x = this.startX, y = this.startY;
    
    while (true) {
      let cell = new Cell(1, 1, currentColor);
      cell.setGridCoords(x, y);
      this.points.push(cell);
      
      if (x === newX && y === newY) break;
      
      const e2 = 2 * err;
      
      // Should we step in x?
      if (e2 > -dy) {
	err -= dy;
	x += sx;
      }
      
      // Should we step in y?
      if (e2 < dx) {
	err += dx;
	y += sy;
      }
    }
  }
}

class Cell {
  constructor(x, y, c) {
    this.row = Math.floor(x/width*rows);
    this.col = Math.floor(y/height*cols);
    this.id = this.hashPosition(this.row, this.col);
    this.color = c;
  }

  setGridCoords(row, col) {
    this.row = row;
    this.col = col;
    this.id = this.hashPosition(this.row, this.col);
  }

  hashPosition(x, y) {
    return (x + y) * (x + y + 1) / 2 + y;
  }
}


</script>
