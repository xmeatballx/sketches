<script src="./lib/vendor/p5.min.js" data-head ></script>
<script src="./lib/components/range.js" data-head ></script>
<script src="./lib/classes/animation.js" data-head ></script>
<script src="./lib/classes/bresenham-line.js" data-head ></script>
<script src="./lib/classes/clipboard.js" data-head ></script>
<script src="./lib/classes/ui.js" data-head ></script>

<style>
#controls {
   width: 450px;
}

input#cursor {
  width: 100%;
  max-width: none;
}
</style>

<div id="controls">
  <input id="cursor" type="range" min=0 max=0 />
  <fieldset>
    <button type="button" id="copy-frame">Copy frame</button>
    <button type="button" id="paste-frame">Paste frame</button>
    <button type="button" id="duplicate">Duplicate</button>
    <button type="button" id="clear">Clear</button>
  </fieldset>
  <fieldset>
    <button type="button" id="play">Play</button>
    <button type="button" id="pause">Pause</button>
    <button type="button" id="stop">Stop</button>
  </fieldset>
  <fieldset>
    <input type="color" id="color"/>
    <input type="radio" id="pencil" value="pencil" name="mode"/>
    <label for="pencil">Pencil</label>
    <input type="radio" id="line" value="line" name="mode"/>
    <label for="line">Line</label>
    <input type="radio" id="eraser" value="eraser" name="mode"/>
    <label for="eraser">Eraser</label>
  </fieldset>
  <fieldset>
    <div>
      <label for="frameRate">Frame rate</label>
      <input type="number" id="frameRate" value="12"/>
    </div>
    <div>
      <label for="frames">Number of Frames</label>
      <input type="number" id="frames" value="12"/>
    </div>
  </fieldset>
</div>

<script>
let ui = new UI().initialize({
  playhead: document.getElementById("cursor"),
  copyFrameButton: document.getElementById("copy-frame"),
  pasteFrameButton: document.getElementById("paste-frame"),
  duplicateButton: document.getElementById("duplicate"),
  clearButton: document.getElementById("clear"),
  playButton: document.getElementById('play'),
  pauseButton: document.getElementById('pause'),
  stopButton: document.getElementById('stop'),
  frameRateInput: document.getElementById('frameRate'),
  frameCountInput: document.getElementById('frames'),
  colorInput: document.getElementById('color'),
  modeInputs: document.querySelectorAll('[name="mode"]'),
});

ui.registerAction('playheadMove', ui.elements.playhead, 'input');
ui.registerAction('copyFrame', ui.elements.copyFrameButton, 'click');
ui.registerAction('pasteFrame', ui.elements.pasteFrameButton, 'click');
ui.registerAction('duplicateFrame', ui.elements.duplicateButton, 'click');
ui.registerAction('clearFrame', ui.elements.clearButton, 'click');
ui.registerAction('play', ui.elements.playButton, 'click');
ui.registerAction('pause', ui.elements.pauseButton, 'click');
ui.registerAction('stop', ui.elements.stopButton, 'click');
ui.registerAction('frameRateChange', ui.elements.frameRateInput, 'change');
ui.registerAction('frameCountChange', ui.elements.frameCountInput, 'change');
ui.registerAction('colorChange', ui.elements.colorInput, 'change');
ui.registerAction('modeChange', ui.elements.modeInputs, 'click');
</script>

<script id="sketch">
let canvasWidth = 450,
    canvasHeight = 450,
    rows = 32,
    cols = 32,
    rowWidth = canvasWidth / rows,
    colWidth = canvasHeight / cols,
    mode = 'pencil',
    timeline,
    clipboard,
    currentColor;

function setup() {
  createCanvas(canvasWidth, canvasHeight);

  timeline = new Animation(() => new Frame());
  clipboard = new Clipboard();
  currentColor = color(0);

  ui.registerCanvas('.p5Canvas');
  ui.onCanvasMouseDown(() => handleDraw(true));
  ui.onCanvasMouseDrag(handleDraw);

  ui.on('playheadMove', (e) => timeline.scrub(parseInt(e.target.value)));
  ui.on('copyFrame', () => clipboard.copy(timeline.getCurrentFrame(), frame => frame.copy()));
  ui.on('pasteFrame', () => timeline.setFrame(timeline.currentFrame, clipboard.paste()));
  ui.on('duplicateFrame', () => {
    clipboard.copy(timeline.getCurrentFrame(), frame => frame.copy());
    timeline.setFrame(timeline.currentFrame + 1, clipboard.paste());
    timeline.scrub(timeline.currentFrame + 1);
  });
  ui.on('clearFrame', () => timeline.setFrame(timeline.currentFrame, new Frame()));
  ui.on('play', timeline.play);
  ui.on('pause', timeline.pause);
  ui.on('stop', timeline.stop);
  ui.on('frameRateChange', (e) => timeline.frameRate = parseInt(e.target.value));
  ui.on('frameCountChange', (e) => timeline.setLength(parseInt(e.target.value)));
  ui.on('colorChange', (e) => currentColor = color(e.target.value));
  ui.on('modeChange', (e) => mode = e.target.value);

  timeline.frameRate = parseInt(ui.elements.frameRateInput.value);
  timeline.setLength(parseInt(ui.elements.frameCountInput.value));

  rectMode("CENTER");
}

function draw() {
  background(255);
  timeline.update(deltaTime);

  ui.elements.playhead.value = timeline.currentFrame;
  ui.elements.playhead.max = timeline.frames.length - 1;

  if (timeline.playState !== 'playing') {
    let prevCells = timeline.getFrame(timeline.currentFrame-1)?.filledCells;
    drawGrid();
    if (prevCells) {
      drawCells(prevCells, color(255, 0, 0, 20));
    }
  }

  let cells = timeline.getCurrentFrame().filledCells;
  drawCells(cells);
}

function drawGrid() {
  push();
  stroke(0, 0, 0, 20);
  for (x = 0; x < rows; x++) {
    line(x*rowWidth, 0, x*rowWidth, height); 
  }

  for (y = 0; y < cols; y++) {
    line(0, y*colWidth, width, y*colWidth);
  }
  pop();
}

function drawCells(cells, cellColor = null) {
  for (const cell of cells) {
    let x = (rowWidth*cell.row);
    let y = (colWidth*cell.col);
    fill(cellColor ?? cell.color);
    noStroke();
    rect(x, y, rowWidth, colWidth);
  }
}

function handleDraw(isClick = false) {
  switch(mode) {
    case 'pencil':
      timeline.getCurrentFrame().drawPoint(mouseX, mouseY);
      break;
    case 'line':
      if (isClick) timeline.getCurrentFrame().startLine(mouseX, mouseY);
      else timeline.getCurrentFrame().updateLine(mouseX, mouseY);
      break;
    case 'eraser':
      timeline.getCurrentFrame().erasePoint(mouseX, mouseY);
  }
}

class Frame {
  constructor(cells = []) {
    this.filledCells = cells;
    this.line = new BresenhamLine();
    this.prevLineLength = 0;
  }

  startLine(x, y) {
    const cellCoords = new Cell(x, y);
    this.line.start(cellCoords.row, cellCoords.col);
    this.prevLineLength = 0;
  }

  updateLine(newX, newY) {
    const cellCoords = new Cell(newX, newY);
    this.line.calculate(cellCoords.row, cellCoords.col);
    for (let i = 0; i < this.prevLineLength; i++) {
      this.filledCells.pop();
    }
    this.prevLineLength = 0;
    for (const cell of this.line.points) {
      const existingCell = this.filledCells.find(filledCell => filledCell.id === cell.id);
      if (existingCell) {
	existingCell.color = cell.color;	
      } else {
	this.filledCells.push(cell);
	this.prevLineLength++;
      }
    }
  }

  drawPoint(x, y) {
    const cell = new Cell(x, y, currentColor);
    const existingCell = this.filledCells.find(filledCell => filledCell.id === cell.id);
    if (!existingCell) this.filledCells.push(cell);
  }

  erasePoint(x, y) {
    const cellCoords = new Cell(x, y);
    const existingCellIdx = this.filledCells.findIndex(filledCell => filledCell.id === cellCoords.id);
    if (existingCellIdx > -1) {
      this.filledCells.splice(existingCellIdx, 1);
    }
  }

  copy() {
    return new Frame([...this.filledCells]);
  }
}

class Cell {
  constructor(x, y, c) {
    this.row = Math.floor(x/width*rows);
    this.col = Math.floor(y/height*cols);
    this.id = this.hashPosition(this.row, this.col);
    this.color = c;
  }

  setGridCoords(row, col) {
    this.row = row;
    this.col = col;
    this.id = this.hashPosition(this.row, this.col);
  }

  hashPosition(x, y) {
    return (x + y) * (x + y + 1) / 2 + y;
  }
}
</script>
